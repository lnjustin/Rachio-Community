/**
 *  Rachio Hose Timer Valve Device Handler
 *
 *  Copyright\u00A9 2023 Justin Leonard
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 * Version info in Rachio Community App
 */

import java.text.SimpleDateFormat

Integer statusRefresh() { return 60 }

metadata {
    definition (name: "Rachio Hose Timer", namespace: "lnjustin", author: "Justin Leonard") {
        capability "Refresh"
        capability "Switch"
        capability "Actuator"
        capability "Valve"
        capability "Sensor"
        capability "Polling"
        capability "Health Check"

        attribute "valveName", "string"
        attribute "valveColor", "string"
      //  attribute "valvePhoto", "string"

        attribute "watering", "string"
        attribute "valveWaterTime", "number"
        
        attribute "connected", "string"
        attribute "lastSeen", "string"
        attribute "batteryStatus", "string"
        attribute "firmwareVersion", "string"  
        attribute "defaultRunTimeSecs", "number"
        attribute "changesPending", "string"

        attribute "lastAction", "string"
        attribute "lastActionStart", "string"
        attribute "lastActionStartStr", "string"
        attribute "lastActionMinsDuration", "string"
        attribute "lastActionProgramName", "string"
        attribute "lastActionFlowDetected", "string"

        attribute "nextAction", "string"
        attribute "nextActionStart", "string"
        attribute "nextActionStartStr", "string"
        attribute "nextActionMinsDuration", "string"
        attribute "nextActionProgramName", "string"

        attribute "lastUpdatedDt", "string"
        attribute "notificationMessage", "string"

        attribute "DeviceWatch-DeviceStatus", "string"

        command "stopWatering"

        command "startWatering"
        command "decValveWaterTime"
        command "incValveWaterTime"
        command "setValveWaterTime", ["number"]

        command "setValveDefaultWaterTime", ["number"]

        command "skipNextProgramRun"
        command "cancelPendingSkip"
    }

    simulator {
        // TODO: define status and reply messages here
    }

    tiles (scale: 2){
        multiAttributeTile(name: "valveTile", type: "generic", width: 6, height: 4) {
            tileAttribute("device.watering", key: "PRIMARY_CONTROL" ) {
                attributeState "on", label: 'Watering', action: "close", icon: "st.valves.water.open", backgroundColor: "#00A7E1", nextState: "updating"
                attributeState "off", label: 'Off', action: "open", icon: "st.valves.water.closed", backgroundColor: "#7e7d7d", nextState:"updating"
                attributeState "offline", label: 'Offline', icon: "st.valves.water.closed", backgroundColor: "#FE2E2E"
                attributeState "updating", label:"Working"
            }
        }
        valueTile("valveName", "device.valveName", inactiveLabel: true, width: 3, height: 1, decoration: "flat", wordWrap: true) {
            state("default", label: 'Valve:\n${currentValue}')
        }

        valueTile("blank11", "device.blank", width: 1, height: 1, decoration: "flat") {
            state("default", label: '')
        }

        valueTile("valveWaterTime", "device.valveWaterTime", width: 2, height: 1, decoration: "flat") {
            state "default", label:'Manual Valve Time:\n${currentValue} Minutes'
        }
        
        //Valve Water time control
        valueTile("setValveDefaultWaterTime", "device.setValveDefaultWaterTime", width: 2, height: 1, decoration: "flat") {
            state "default", label:'Default Watering Time:\n${currentValue} Minutes'
        }
        controlTile("valveWaterTimeSliderTile", "device.valveWaterTime", "slider", width: 4, height: 1, range:'(0..60)') {
            state "default", label: 'Manual Valve Time', action:"setValveWaterTime"
        }
        standardTile("rightValveTimeButton", "device.valveWaterTime", inactiveLabel: false, decoration: "flat") {
            state "default", action:"incValveWaterTime", icon:"st.thermostat.thermostat-right"
        }
        valueTile("valveWaterTimeVal", "device.valveWaterTime", inactiveLabel: false, width: 2 , height: 1, decoration: "flat") {
            state "default", label: 'Water Time\n${currentValue} Minutes'
        }
        valueTile("startWateringTile", "device.valveWaterTime", inactiveLabel: false, width: 2 , height: 1, decoration: "flat") {
            state "default", label: 'Run This Valve\n${currentValue} Minutes', action:'startWatering'
        }

        standardTile("refresh", "device.power", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
        }
    }
    main "valveTile"
    details(["valveTile", "valveName", "leftValveTimeButton", "valveWaterTime", "rightValveTimeButton", "startWateringTile", "lastUpdatedDt", "refresh"])
}

// parse events into attributes
def parse(String description) {
    LOG("Parsing '${description}'", 5, "trace")
}

def initialize() {
    sendEvent(name: "DeviceWatch-DeviceStatus", value: "online", displayed: false, isStateChange: true)
    sendEvent(name: "DeviceWatch-Enroll", value: groovy.json.JsonOutput.toJson(["protocol":"cloud", "scheme":"untracked"]), displayed: false)
    verifyDataAttr()
}

def verifyDataAttr() {
    updateDataValue("HealthEnrolled", "true")
    updateDataValue("manufacturer", "Rachio")
    def gen = state?.deviceId ? parent?.getDevGeneration(state?.deviceId) : null
    updateDataValue("model", "${device?.name}${gen ? " ($gen)" : ""}")
}

void installed() {
    state.isInstalled = true
    initialize()
}

void updated() {
    initialize()
}

def generateEvent(Map results) {
    if(results) {
        LOG("generate Event for Valve. Results:" + results, 3, "debug")
        state?.valveId = results?.valveData?.valve.id
        state?.baseStationId = results?.baseStationData?.baseStation.id

        valveNameEvent(results?.valveData?.valve.name)
        valveColorEvent(results?.valveData?.valve.color)
      //  valvePhotoEvent(results?.valveData?.photo.id)

        // process programs before state, so that program names will be available
        valveProgramEvent(results?.programData.programs)

        valveStateEvent(results?.valveData?.valve.state)
        if(state?.isOnline == false) {
            LOG("Rachio serves report the hose timer valve is offline. Marking valve as offline: ${res}", 3, "debug")
            markOffLine()
        }
        else if (state?.isOnline == true) valveFlowEvent(results?.valveData?.valve.detectFlow)

        dayViewEvent(results?.dayViewData?.valveDayViews)

        if(!device?.currentState("valveWaterTime")?.value) {
            setValveWaterTime(parent?.getValveRunTimeDefaultSetting())
        }

        if(isOnline) { lastUpdatedEvent() }
    }
    return "hello from zone"
}

def getDurationDesc(long secondsCnt) {
    int seconds = secondsCnt %60
    secondsCnt -= seconds
    long minutesCnt = secondsCnt / 60
    long minutes = minutesCnt % 60
    minutesCnt -= minutes
    long hoursCnt = minutesCnt / 60
    return "${minutes} min ${(seconds >= 0 && seconds < 10) ? "0${seconds}" : "${seconds}"} sec"
}

def getDurationMinDesc(long secondsCnt) {
    int seconds = secondsCnt %60
    secondsCnt -= seconds
    long minutesCnt = secondsCnt / 60
    long minutes = minutesCnt % 60
    minutesCnt -= minutes
    long hoursCnt = minutesCnt / 60
    return "${minutes}"
}

def lastUpdatedEvent() {
    def lastDt = formatDt(new Date())
    def lastUpd = device?.currentState("lastUpdatedDt")?.stringValue
    state?.lastUpdatedDt = lastDt?.toString()
    if(isStateChange(device, "lastUpdatedDt", lastDt.toString())) {
        LOG("${device?.displayName} is ${state?.isOnline ? "Online and Active" : "OFFLINE"}) - Last Updated: (${lastDt})", 4, "info")
        sendEvent(name: 'lastUpdatedDt', value: lastDt?.toString(), displayed: false)
    }
}

def markOffLine() {
	if(isStateChange(device, "watering", "offline")) { 
		LOG("UPDATED: Watering (Offline)", 5, "trace")
		sendEvent(name: 'watering', value: "offline", displayed: true, isStateChange: true)
		sendEvent(name: 'valve', value: "closed", displayed: false, isStateChange: true)
		sendEvent(name: 'switch', value: "off", displayed: false, isStateChange: true)
	}
	if(isStateChange(device, "valveRunStatus", "Device in Offline")) {
		sendEvent(name: 'valveRunStatus', value: "Device is Offline", displayed: false, isStateChange: true)
	}
    setWatchDogStatus()
}

def valveFlowEvent(isFlowDetected) {
    LOG("valveFlowEvent...", 5, "trace")
    def curState = device?.currentState("watering")?.value.toString()
    def newState = (isFlowDetected == "true" || isFlowDetected == true) ? "on" : "off"
    LOG("Watering is (${newState}) | Previous: (${curState})", 3, "debug")
    if(isStateChange(device, "watering", newState.toString())) {
        LOG("UPDATED: Watering (${newState}) | Previous: (${curState})", 3, "debug")
        sendEvent(name: 'watering', value: newState, displayed: true, isStateChange: true)
        sendEvent(name: 'switch', value: ((isFlowDetected == "true" || isFlowDetected == true) ? "on" : "off"), displayed: false, isStateChange: true)
        sendEvent(name: 'valve', value: ((isFlowDetected == "true" || isFlowDetected == true) ? "open" : "closed"), displayed: false, isStateChange: true)
    }
}

def valveNameEvent(val) {
    def curState = device?.currentState("valveName")?.value.toString()
    def newState = val ? val.toString() : "unknown"
    if(isStateChange(device, "valveName", newState.toString())) {
        LOG("UPDATED: Valve Name (${newState}) | Previous: (${curState})", 3, "debug")
        sendEvent(name:'valveName', value: newState, displayed: true)
    }
}

def valveColorEvent(val) {
    def curState = device?.currentState("valveColor")?.value.toString()
    def newState = val ? val.toString() : "unknown"
    if(isStateChange(device, "valveColor", newState.toString())) {
        LOG("UPDATED: Valve Color (${newState}) | Previous: (${curState})", 3, "debug")
        sendEvent(name:'valveColor', value: newState, displayed: true)
    }
}

def setWatchDogStatus() {
    def onlStatus = state?.isOnline == true ? "online" : "offline"
    sendEvent(name: "DeviceWatch-DeviceStatus", value: onlStatus, displayed: false)
}

def valveStateEvent(stateData) {
    LOG("ValveStateEvent: (${stateData})", 5, "trace")
    state?.stateData = stateData

    def reportedState = stateData?.reportedState
    if (reportedState.connected != null) sendEvent(name:'connected', value: reportedState?.connected)
    state?.isOnline = (reportedState.connected == "true" || reportedState.connected == true) ? true : false
    if(state?.isOnline == false) {
        LOG("Rachio reports the hose timer valve as being offline. Marking valve as offline: reportedState = ${reportedState.connected} of type ${reportedState.connected.class}", 3, "debug")
        markOffLine()
    }
    setWatchDogStatus()

    if (reportedState.lastSeen) sendEvent(name:'lastSeen', value: formatUtcDt(reportedState.lastSeen))
    if (reportedState.batteryStatus) sendEvent(name:'batteryStatus', value: reportedState.batteryStatus)
    if (reportedState.firmwareVersion) sendEvent(name:'firmwareVersion', value: reportedState.firmwareVersion)

    if (reportedState.defaultRuntimeSeconds) sendEvent(name:'defaultRunTimeSecs', value: reportedState.defaultRuntimeSeconds)
    
    if (stateData.matches != null) {
        def changesPendingVal = (stateData.matches == "false" || stateData.matches == false) ? true : false
        sendEvent(name:'changesPending', value: changesPendingVal)
        if (changesPendingVal == true) handleChangesPending()
    }

    def lastAction = reportedState.lastWateringAction
    if (lastAction && lastAction.start) {
        sendEvent(name:'lastActionStartStr', value: formatUtcDt(lastAction.start))
        sendEvent(name:'lastActionStart', value: getUnixDtFromUTCDt(lastAction.start) )
    }
    if (lastAction && lastAction.durationSeconds) {
        BigDecimal secs = lastAction.durationSeconds.toBigDecimal()
        BigDecimal mins = secs/60
        Integer roundedMins = Math.ceil(mins)
        sendEvent(name:'lastActionMinsDuration', value: mins)
    }
    if (lastAction && lastAction.reason) sendEvent(name:'lastAction', value: lastAction.reason)
    if (lastAction && lastAction.flowDetected) sendEvent(name:'lastActionFlowDetected', value: lastAction.flowDetected)
    if (lastAction && lastAction.programId && state.programs[lastAction.programId]) sendEvent(name:'lastActionProgramName', value: state.programs[lastAction.programId])
}

def valveProgramEvent(programs) {
    LOG("valveProgramEvent: ${programs}", 5, "trace")
    if (!state.programs) state.programs = [:]
    programs.each { program ->
        LOG("Found Program: ${program}", 3, "debug")
        state.programs[program.id] = program.name
    }
}

def dayViewEvent(dayViewData) {
    setNextActionEvents(dayViewData)
}

def setNextActionEvents(dayViewData) {
    LOG("setNextActionEvents: with dayViewData = ${dayViewData}", 4, "info")

    // API provides no guarantee about the sorting of this data structure, so need to ensure select the earliest next action
    if (!dayViewData) {
        LOG("No upcoming actions for valve.", 4, "info")
        return
    }
    def nextAction = [:]
    dayViewData.each { day ->
    // must traverse every day, because no guarantee of ordering. Plus, cannot rely on the day part of the data since different time zones could be in play
        LOG("Processing Day: ${day}", 4, "info")
        day.valveProgramRunSummaries?.each { programAction ->
            if (state.programs?.containsKey(programAction?.programId)) {
                // program contains this valve
                programAction?.valveRunSummaries?.each { valveRun ->
                    nextAction = processValveRunForNextAction("Program Run", valveRun, nextAction, programAction)
                }
            }
        }
        day.valveQuickRunSummaries?.each { quickAction ->
            quickAction?.valveRunSummaries?.each { valveRun ->
                nextAction = processValveRunForNextAction("Quick Run", valveRun, nextAction)
            }
        }
        day.valveManualRunSummaries?.each { manualAction ->
            manualAction?.valveRunSummaries?.each { valveRun ->
                nextAction = processValveRunForNextAction("Manual Run", valveRun, nextAction)
            }
        }
    }
    if (nextAction != null && nextAction != [:]) {
        if (nextAction.action) sendEvent(name:'nextAction', value: nextAction.action)
        if (nextAction.start) {
            sendEvent(name:'nextActionStartStr', value: formatUtcDt(nextAction.start))
            sendEvent(name:'nextActionStart', value: getUnixDtFromUTCDt(nextAction.start) )
        }
        if (nextAction.durationSeconds) {
            LOG("next action duration seconds = ${nextAction.durationSeconds}")
            BigDecimal secs = nextAction.durationSeconds.toBigDecimal()
            BigDecimal mins = secs/60
            Integer roundedMins = Math.ceil(mins)
            sendEvent(name:'nextActionMinsDuration', value: roundedMins)
        }
        sendEvent(name:'nextActionProgramName', value: nextAction.programName ?: "None")

        if (nextAction.programId != null) {
            // save next action state for creating or deleting skips if needed
            state.nextActionProgramId = nextAction.programId
            state.nextActionProgramTimestamp = nextAction.programTime
        }
        else {
            state.nextActionProgramId = null
            state.nextActionProgramTimestamp = null
        }
        
    }
    else {
        LOG("No upcoming runs of valveId ${state.valveId}.", 4, "info")
        sendEvent(name:'nextAction', value: "None")
        sendEvent(name:'nextActionStartStr', value: "None")
        sendEvent(name:'nextActionStart', value: "None")    
        sendEvent(name:'nextActionMinsDuration', value: "None")  
        sendEvent(name:'nextActionProgramName', value: "None") 
    }
}

def processValveRunForNextAction(runType, valveRun, nextAction, programAction = null) {
    def newNextAction = nextAction
    if (valveRun.valveId == state?.valveId) {
        def now = new Date()
        def action = runType
        if (valveRun.skip) {
            if (valveRun.skip?.manualOverrideTrigger) action = "Manual Skip"
            else if (valveRun.skip?.rainOverrideTrigger) action = "Rain Skip"
        }
        def startDate = getDateObjectFromUTCDt(valveRun.start)
        LOG("Comparing time now ${now} to start date of ${startDate}", 4, "debug")
        if (startDate.after(now)) {
            if (nextAction == null || nextAction == [:]) {
                newNextAction = [action: action, start: valveRun.start, durationSeconds: valveRun.durationSeconds, programName: programAction?.programName, programId: programAction?.programId, programTime: programAction?.start]
                LOG("Setting new nextAction to ${newNextAction}", 4, "debug")
            }
            else {
                def nextActionDate = getDateObjectFromUTCDt(nextAction?.start)
                if (nextActionDate.after(startDate)) {
                    newNextAction = [action: action, start: valveRun.start, durationSeconds: valveRun.durationSeconds, programName: programAction?.programName, programId: programAction?.programId, programTime: programAction?.start]
                    LOG("Setting new nextAction to ${newNextAction}", 4, "debug")
                }
            }
        }
    }
    return newNextAction
}

def handleChangesPending() {
    LOG("Asynchornous changes to Hose Timer Valve settings are still pending and have not yet been downloaded to the value yet. State of Valve is only tentative.)", 1, "warn")
}

def fmtString(str) {
    if(!str) { return null }
    def out = []
    def tmp = str?.replaceAll("_", " ")?.toLowerCase()?.split(" ")
    tmp?.each { out.push(it?.toString().capitalize()) }
    return out.join(" ")
}

def refresh() {
    LOG("refresh...", 5, "trace")
    poll()
}

void poll() {
    LOG("Requested Parent Poll...", 5, "trace");
    parent?.pollChild(this, "hoseTimerDevice")
}
  
def setValveWaterTime(timeVal) {
    def curState = device?.currentState("valveWaterTime")?.value.toString()
    def newVal = timeVal ? timeVal.toInteger() : getDefaultRunTime()
    if(isStateChange(device, "valveWaterTime", newVal.toString())) {
        LOG("UPDATED: Manual Valve Water Time (${newVal}) | Previous: (${curState})", 3, "debug")
        sendEvent(name: 'valveWaterTime', value: newVal, displayed: true)
    }
}

def getDefaultRunTime() {
    return device?.currentState("defaultRunTimeSecs")?.value ?: 10
}

def incValveWaterTime() {
    LOG("Decrease Valve Runtime", 5, "trace")
    def value = device.latestValue('valveWaterTime')
    setValveWaterTime(value + 1)
}

def decValveWaterTime() {
    LOG("Increase Valve Runtime", 5, "trace")
    def value = device.latestValue('valveWaterTime')
    setValveWaterTime(value - 1)
}

def isCmdOk2Run() {
    LOG("isCmdOk2Run...", 5, "trace")
    if(state?.isOnline == false) {
        LOG("Skipping the request... Because the valve is unable to send commands while it's in an Offline State.", 1, "warn")
        return false
    }
    else { return true }
}

def startWatering(mins=null) {
    // mins may be set by the wifi hub device
    LOG("startWatering()...", 5, "trace")
    if(!isCmdOk2Run()) { return }
    def waterTime = getDefaultRunTime()
    if (mins == null && device?.latestValue('valveWaterTime') != null) waterTime = device?.latestValue('valveWaterTime')
    else if (mins != null) waterTime = mins
    LOG("Starting Watering for (${waterTime}) Minutes", 3, "debug")
    def res = parent?.startValve(this, waterTime)
    if (res) {
        LOG("startWatering was Sent Successfully: ${res}", 3, "debug")
        sendWateringEvents(true)
    }
    else {
        LOG("Rachio reports startWatering was unsuccessful. Marking valve as offline: ${res}", 3, "debug")
        markOffLine()
    }
    return res
}

def stopWatering() {
    LOG("stopWatering()...", 5, "trace")
   // if(!isCmdOk2Run()) { return }
    def isClosed = device?.currentState("valve")?.value.toString() == "closed" ? true : false
    if (!isClosed) {
        def res = parent?.stopValve(this)
        if (res) {
            LOG("Valve was Stopped Successfully...", 4, "info")
            sendWateringEvents(false)
        }
        else {
            LOG("Rachio reports stopWatering was unsuccessful. Marking valve as offline: ${res}", 3, "debug")
            markOffLine()
        }
    } else { LOG("Valve is Already Closed... Ignoring...", 4, "info") }
}

def on() {
    LOG("valve on...", 5, "trace")
    if(!isCmdOk2Run()) { return }
    def isOn = device?.currentState("switch")?.value.toString() == "on" ? true : false
    if (!isOn) { startWatering() }
    else { LOG("Valve is Already ON... Ignoring...", 4, "info") }
}

def off() {
    LOG("valve off...", 5, "trace")
    //if(!isCmdOk2Run()) { return }
    def isOff = device?.currentState("switch")?.value.toString() == "off" ? true : false
    if (!isOff) { stopWatering() }
    else { LOG("Valve is Already OFF... Ignoring...", 4, "info") }
}

def open() {
    LOG("Valve open()...", 5, "trace")
    if(!isCmdOk2Run()) { return }
    def isOpen = device?.currentState("valve")?.value.toString() == "open" ? true : false
    if (!isOpen) {
        startWatering()
    }
    else { LOG("Valve is Already Open... Ignoring...", 4, "info") }
}

def close() {
    LOG("Valve close()...", 5, "trace")
    //if(!isCmdOk2Run()) { return }
    def isClosed = device?.currentState("valve")?.value.toString() == "closed" ? true : false
    if (!isClosed) {
        stopWatering()
    } else { LOG("Valve is Already Closed... Ignoring...", 4, "info") }
}

def sendWateringEvents(isWatering) {
    if (isWatering == true) {
        sendEvent(name:'switch', value: "on", displayed: false, isStateChange: true)
        sendEvent(name:'valve', value: "open", displayed: false, isStateChange: true)
        sendEvent(name:'watering', value: "on", displayed: true, isStateChange: true)
    }
    else {
        sendEvent(name:'switch', value: "off", displayed: false, isStateChange: true)
        sendEvent(name:'valve', value: "closed", displayed: false, isStateChange: true)
        sendEvent(name:'watering', value: "off", displayed: true, isStateChange: true)
    }
    if (state?.baseStationId != null) parent?.updateBaseStationWateringState(state?.baseStationId)
}

def isWatering() {
    return device?.currentState("valve")?.value.toString() == "open" ? true : false
}

def setValveDefaultWaterTime(waterTime) {
    LOG("setValveDefaultWaterTime(${waterTime})...", 5, "trace")
    if(!isCmdOk2Run()) { return }
    def res = parent?.setValveDefaultRunTime(this, waterTime)
    if (res) {
        LOG("setValveDefaultWaterTime was Sent Successfully: ${res}", 3, "debug")
    }
    else {
        LOG("Rachio reports setValveDefaultWaterTime was unsuccessful. Marking valve as offline: ${res}", 3, "debug")
        markOffLine()
    }
}

def skipNextProgramRun() {
    if (device.latestValue('nextAction') == "Program Run" && state.nextActionProgramId && state.nextActionProgramTimestamp) {
        def res = parent?.createHoseTimerProgramSkip(state.nextActionProgramId, state.nextActionProgramTimestamp)
        if (res) {
            runIn(10, "poll") // resynch 
        }
        else LOG("Error skipping next run", 1, "warn")
    }
    else {
        LOG("No Next Run to Skip", 1, "warn")
    }
}

def cancelPendingSkip() {
    if ((device.latestValue('nextAction') == "Manual Skip" || device.latestValue('nextAction') == "Rain Skip") && state.nextActionProgramId && state.nextActionProgramTimestamp) {
        def res = parent?.deleteHoseTimerProgramSkip(state.nextActionProgramId, state.nextActionProgramTimestamp)
        if (res) {
            runIn(10, "poll") // resynch 
        }
        else LOG("Error canceling pending skip", 1, "warn")
    }
    else {
        LOG("No Pending Skip to Cancel", 1, "warn")
    }
}

def getDtNow() {
	def now = new Date()
	return formatDt(now, false)
}

def epochToDt(val) {
    if(val) { return formatDt(new Date(val)) }
}

def formatDt(dt, mdy = true) {
	def formatVal = mdy ? "MMM d, yyyy - h:mm:ss a" : "E MMM dd HH:mm:ss z yyyy"
	def tf = new SimpleDateFormat(formatVal)
	if(location?.timeZone) { tf.setTimeZone(location?.timeZone) }
	return tf.format(dt)
}

//Returns time differences is seconds
def GetTimeValDiff(timeVal) {
    try {
        def start = new Date(timeVal).getTime()
        def now = new Date().getTime()
        def diff = (int) (long) (now - start) / 1000
        LOG("diff: $diff", 3, "debug")
        return diff
    }
    catch (ex) {
        LOG("GetTimeValDiff Exception: ${ex}", 1, "error")
        return 1000
    }
}

def getTimeDiffSeconds(strtDate, stpDate=null) {
	if((strtDate && !stpDate) || (strtDate && stpDate)) {
		def now = new Date()
		def stopVal = stpDate ? stpDate.toString() : formatDt(now, false)
		def start = Date.parse("E MMM dd HH:mm:ss z yyyy", strtDate).getTime()
		def stop = Date.parse("E MMM dd HH:mm:ss z yyyy", stopVal).getTime()
		def diff = (int) (long) (stop - start) / 1000
		return diff
	} else { return null }
}

def getTimeDiffSecondsUtc(strtDate, stpDate) {
	if(strtDate && stpDate) {
		def start = getUnixDtFromUTCDt(strtDate)
        def stop = getUnixDtFromUTCDt(stpDate)
		def diff = (int) (long) (stop - start) / 1000
		return diff
	} else { return null }
}

def getUnixDtFromUTCDt(utcDt) {
     def inFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
    inFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
    Date date = inFormat.parse(utcDt)
    return date.getTime()
}

def getDateObjectFromUTCDt(utcDt) {
    def inFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
    inFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
    return inFormat.parse(utcDt)
}

def formatUtcDt(utcDt, mdy = true) {
    def inFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSSSS'Z'")
    inFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
    
	LOG("formatDt($utcDt, $mdy)...", 5, "trace")
	def formatVal = mdy ? "MMM d, yyyy - h:mm:ss a" : "E MMM dd HH:mm:ss z yyyy"
	def outFormat = new SimpleDateFormat(formatVal)
    if(location?.timeZone) { outFormat.setTimeZone(location?.timeZone) }
    
  //  if (utcDt == null) return null
    
    def parsedInFormat = null
    try {
        parsedInFormat = inFormat.parse(utcDt)
    } 
    catch (ex1) {
        try {
            inFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
            inFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
            parsedInFormat = inFormat.parse(utcDt)
        }
        catch (ex2) {
            inFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
            inFormat.setTimeZone(TimeZone.getTimeZone("UTC"))
            parsedInFormat = inFormat.parse(utcDt)
        }
    }

	return outFormat.format(parsedInFormat)
}

def convertSecstoTimeStr(int secondsToConvert) {
    long hours = TimeUnit.SECONDS.toHours(secondsToConvert)
    long minutes = TimeUnit.SECONDS.toMinutes(secondsToConvert) % TimeUnit.HOURS.toMinutes(1)
    long seconds = TimeUnit.SECONDS.toSeconds(secondsToConvert) % TimeUnit.MINUTES.toSeconds(1)

    if (hours == 0) return String.format("%02d:%02d", Math.abs(minutes), Math.abs(seconds))
    else return String.format("%02d:%02d:%02d", Math.abs(hours), Math.abs(minutes), Math.abs(seconds))
}

// generate custom mobile activity feeds event
void generateActivityFeedsEvent(notificationMessage) {
	sendEvent(name: "notificationMessage", value: "${device.name} ${notificationMessage}", descriptionText: "${device.name} ${notificationMessage}", isStateChange: true)
}

void LOG(String message, Integer level=3, String logType="debug") {
    String dbg=parent?.getDebugLevel()
    log.debug "Debug Level = ${dbg}"
	Integer dbgLevel = dbg.toInteger()
	if (logType == "error") {Ã“
		String a=getTimestamp()
		state.lastLOGerror="${message} @ "+a
		state.LastLOGerrorDate=a
	} else {
		if(level > dbgLevel) return
	}
    def List<String> lLOGTYPES =	['error', 'debug', 'info', 'trace', 'warn']
	if(!lLOGTYPES.contains(logType)) {
		logerror("LOG() - Received logType (${logType}) which is not in the list of allowed types ${lLOGTYPES}, message: ${message}, level: ${level}")
		logType="debug"
	}
    if (logType == "debug") log.debug(message)
    else if (logType == "error") log.error(message)
    else if (logType == "info") log.info(message)
    else if (logType == "trace") log.trace(message)
    else if (logType == "warn") log.warn(message)
}
